Лабораторная работа №3
---
___Тема:___ Использование принципов проектирования на уровне методов и классов
___Цель работы:___ Получить опыт проектирования и реализации модулей с использованием принципов KISS, YAGNI, DRY, SOLID и др.

Диаграмма контейнеров
---
![alt text](<../../Lab Work №2/docs/Диаграмма контейнеров.png>)

Диаграмма компонентов
---
![alt text](<../../Lab Work №2/docs/Диаграмма компонентов(1).png>)

![alt text](<../../Lab Work №2/docs/Диаграмма компонентов(2).png>)

Диаграмма последовательностей
---
![alt text](<Диаграмма последовательностей.png>)

Модель БД
---
![alt text](<Модель БД.png>)

1. __User (Пользователь)__
Хранит информацию о зарегистрированных пользователях.

    __Основные атрибуты:__
    - user_id: Уникальный идентификатор пользователя.
    - email: Электронная почта (уникальна для каждого пользователя).
    мpassword_hash: Хэш пароля для безопасного хранения.
    - username: Отображаемое имя.
    - profile_picture: Ссылка на аватар пользователя.
    - created_at: Время создания аккаунта.
    - 
    __Связи:__
    - Связан с таблицей Friend как отправитель или получатель запросов дружбы.
    - Связан с таблицей Message как отправитель или получатель сообщений.
    - Может участвовать в голосовых каналах через связь с ChannelParticipant.
  
2. __Friend (Друзья)__
Описывает отношения между пользователями.

    __Основные атрибуты:__
    - friend_id: Уникальный идентификатор связи дружбы.
    - user_id: Идентификатор пользователя, отправившего запрос дружбы.
    - friend_user_id: Идентификатор пользователя, получившего запрос.
    - status: Состояние запроса (в ожидании, принят, отклонён).
    - created_at: Дата создания или обновления связи.

    __Связи:__
    - Связывает двух пользователей (user_id и friend_user_id).

3. __Message (Сообщения)__
Хранит текстовые сообщения между пользователями.

    __Основные атрибуты:__
    - message_id: Уникальный идентификатор сообщения.
    - sender_id: Пользователь, отправивший сообщение.
    - recipient_id: Пользователь, получивший сообщение.
    - text: Содержимое сообщения.
    - created_at: Время отправки.
    - is_read: Флаг, показывающий, прочитано ли сообщение.

    __Связи:__
    - Каждое сообщение связано с пользователями через sender_id и recipient_id.

4. __Channel (Голосовые каналы)__
Описывает голосовые каналы, созданные пользователями.

    __Основные атрибуты:__
    - channel_id: Уникальный идентификатор канала.
    - name: Название канала.
    - owner_id: Идентификатор пользователя, который создал канал.
    - created_at: Время создания канала.

    __Связи:__
    - Связан с пользователем через owner_id (владелец канала).
    - Содержит участников через таблицу ChannelParticipant.

5. __ChannelParticipant (Участники каналов)__
Описывает пользователей, подключённых к голосовым каналам.

    __Основные атрибуты:__
    - participant_id: Уникальный идентификатор записи.
    - channel_id: Канал, к которому присоединился пользователь.
    - user_id: Пользователь, подключённый к каналу.
    - joined_at: Время подключения пользователя.

    __Связи:__
    - Связывает User и Channel.

__Типы связей:__
- User ↔ Friend:
"Многие ко многим" (каждый пользователь может иметь несколько друзей).

- User ↔ Message:
"Один ко многим" (пользователь может отправлять и получать много сообщений).

- User ↔ ChannelParticipant ↔ Channel:
"Многие ко многим" (пользователь может участвовать в нескольких каналах, а канал может содержать много участников).

- User ↔ Channel:
"Один ко многим" (один пользователь может создать много каналов).

Применение основных принципов разработки
---
1. __Принцип KISS (Keep It Simple, Stupid):__
   Принцип: Решение должно быть максимально простым и понятным, без лишних усложнений.

   ```
    # Плохой пример: сложный и ненужный процесс проверки
    def authenticate_user(email, password):
        user = db.get_user_by_email(email)
        if user and user.is_active and user.password_hash == hash_password(password):
            if user.failed_attempts < 3:  # Дополнительные ненужные проверки
                return generate_token(user)
            else:
                raise Exception("Too many failed attempts")
        else:
            raise Exception("Invalid credentials")

    # Хороший пример: простой и понятный код
    def authenticate_user(email, password):
        user = db.get_user_by_email(email)
        if user and user.password_hash == hash_password(password):
            return generate_token(user)
        raise Exception("Invalid credentials")

   ```
   Как учитывается KISS:
    - Убраны лишние проверки (например, failed_attempts), которые не влияют на ключевую задачу.
    - Код сфокусирован только на основной функциональности.

2. __Принцип YAGNI (You Aren't Gonna Need It):__
   Принцип: Реализуйте только ту функциональность, которая нужна сейчас, избегая добавления ненужного.

   ```
    # Плохой пример: добавлена ненужная логика
    def create_channel(name, description=None, max_participants=10, video_enabled=False):
        # Логика работы с видео не нужна на данном этапе
        if video_enabled:
            setup_video_streaming()
        return db.create_channel(name=name, description=description, max_participants=max_participants)

    # Хороший пример: только базовая функциональность
    def create_channel(name, max_participants=10):
        return db.create_channel(name=name, max_participants=max_participants)

   ```
   Как учитывается YAGNI:
    - Исключена логика, связанная с видео (она может быть добавлена позже, если потребуется).
    - Код сфокусирован только на создании голосового канала.

3. __Принцип DRY (Don't Repeat Yourself):__
   Принцип: Исключите дублирование кода. Логика должна быть переиспользуемой.

   ```
    # Плохой пример: повторяющаяся логика в двух функциях
    def can_access_message(user, message_id):
        message = db.get_message_by_id(message_id)
        return message.sender_id == user.id or message.recipient_id == user.id

    def can_access_channel(user, channel_id):
        channel = db.get_channel_by_id(channel_id)
        return channel.owner_id == user.id or user.id in channel.participants

    # Хороший пример: вынесение проверки в общую функцию
    def has_access(user, resource_owner_id, participants=None):
        return user.id == resource_owner_id or (participants and user.id in participants)

    def can_access_message(user, message_id):
        message = db.get_message_by_id(message_id)
        return has_access(user, message.sender_id, [message.recipient_id])

    def can_access_channel(user, channel_id):
        channel = db.get_channel_by_id(channel_id)
        return has_access(user, channel.owner_id, channel.participants)
   ```
   Как учитывается DRY:
    - Логика проверки доступа вынесена в отдельную функцию has_access.
    - Уменьшено дублирование кода.

4. __Принципы SOLID:__
   __S: Single Responsibility Principle (Принцип единственной ответственности).__
    Каждый класс или модуль должен выполнять только одну задачу.
    ```
    # Плохой пример: один класс отвечает за несколько задач
    class UserService:
        def create_user(self, email, password):
            # Логика создания пользователя
            pass

        def send_email_verification(self, email):
            # Логика отправки email
            pass

    # Хороший пример: разделение задач на классы
    class UserService:
        def create_user(self, email, password):
            # Логика создания пользователя
            pass

    class EmailService:
        def send_email_verification(self, email):
            # Логика отправки email
            pass
    ```
    __O: Open/Closed Principle (Принцип открытости/закрытости)__
    Система должна быть открыта для расширения, но закрыта для модификации.
    ```
    class Message:
        def send(self):
            raise NotImplementedError

    class TextMessage(Message):
        def send(self):
            print("Sending text message")

    class AudioMessage(Message):
        def send(self):
            print("Sending audio message")

    # Использование
    messages = [TextMessage(), AudioMessage()]
    for msg in messages:
        msg.send()
    ```
    __L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков)__
    Объекты подклассов должны заменять объекты родительских классов без нарушения работы программы.
    ```
    class Message:
        def send(self):
            raise NotImplementedError

    class TextMessage(Message):
        def send(self):
            print("Sending text message")
    ```
    __I: Interface Segregation Principle (Принцип разделения интерфейсов)__
    Клиенты не должны зависеть от интерфейсов, которые они не используют.
    ```
    class TextMessageSender:
        def send_text(self):
            pass

    class AudioMessageSender:
        def send_audio(self):
            pass
    ```
   __D: Dependency Inversion Principle (Принцип инверсии зависимостей)__
   Модули верхнего уровня не должны зависеть от модулей нижнего уровня.
   ```
    class MessageSender:
        def __init__(self, sender):
            self.sender = sender

        def send(self):
            self.sender.send()
   ```

Дополнительные принципы разработки
---
1. __BDUF (Big Design Up Front — масштабное проектирование прежде всего)__
    - __Описание:__
    BDUF предполагает, что проектирование и планирование системы проводится до начала разработки. Все архитектурные и проектные решения фиксируются заранее, а изменения в процессе работы минимизируются.

    - __Преимущества:__
      - Снижение риска крупных архитектурных ошибок.
      - Чёткое понимание конечного результата.
      - Лёгкость в управлении проектом и оценке сроков.
    - __Недостатки:__
      - Не подходит для проектов с высокой неопределённостью требований.
      - Может привести к избыточному проектированию, если часть функций не будет реализована.
      - Увеличивает время до начала разработки.
    - __Применимость:__
      - Подходит для проектов с фиксированными и неизменяемыми требованиями, например, если требования чётко определены заказчиком.

    - __Решение:__ 
      - Частичное использование — спланировать архитектуру базовых модулей, но оставить место для изменений.

2. __SoC (Separation of Concerns — принцип разделения ответственности)__
    __Описание:__
    SoC предлагает разделять разные аспекты системы на независимые модули, каждый из которых решает конкретную задачу (например, интерфейс, бизнес-логика, данные).

    - __Преимущества:__
      - Уменьшение сложности системы.
      - Удобство тестирования и сопровождения.
      - Возможность независимой разработки разных модулей.
    - __Недостатки:__
      - Требует больше времени на проектирование.
      - Увеличивает количество интерфейсов между модулями.
    - __Применимость:__
      - Разделение веб-клиента (интерфейс) и API-сервера (логика).
      - Разделение API-сервера и VoIP-сервера для голосовых функций.
    - __Решение:__ 
      - Использовать, так как это улучшит читаемость и масштабируемость системы.

3. __MVP (Minimum Viable Product — минимально жизнеспособный продукт)__
    __Описание:__
    Создание минимального набора функций, которые могут быть полезны пользователям. Развитие продукта происходит на основе обратной связи.

    - __Преимущества:__
      - Быстрое тестирование идей.
      - Минимизация затрат на начальном этапе.
      - Возможность сосредоточиться на главных задачах.
    - __Недостатки:__
      - MVP может выглядеть сырым для пользователей.
      - Не все функции сразу доступны, что может отпугнуть заказчика.
    - __Применимость:__
      - Реализовать авторизацию, базовые чаты и голосовые каналы в первой версии.
      - Остальные функции (например, настройки профиля или сложные системы друзей) можно добавить позже.
    - __Решение:__ 
      - Использовать, чтобы быстро создать функциональную версию для ВКР.

4. __PoC (Proof of Concept — доказательство концепции)__
    __Описание:__
    Разработка небольшого прототипа для проверки идеи, технологии или архитектурного решения.

    - __Преимущества:__
      - Быстрая проверка жизнеспособности идеи.
      - Минимизация риска выбора неподходящих технологий.
      - Возможность аргументировать выбор архитектуры.
    - __Недостатки:__
      - Не создаёт конечного продукта.
      - Требует дополнительного времени на разработку полноценной системы.
    - __Применимость:__
      - Проверить возможность работы VoIP через WebRTC.
      - Протестировать производительность API-сервера на базе FastAPI.
    - __Решение:__ 
      - Использовать для технически сложных компонентов, чтобы избежать проблем на этапе интеграции.